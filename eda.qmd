---
title: "EDA - part 2 (sync data)"
---

```{r}
pacman::p_load(sf, tmap, kableExtra, tidyverse, sfdep, readxl, plyr, Kendall, plotly, dplyr, stringdist)
```

```{r}
IPC <- read_rds("data/aspatial/rds/IPC.rds")
#SLL <- read_rds("data/aspatial/rds/SLL.rds")
```

Base Layer

```{r}
mpsz <- st_read(dsn = "data/geospatial/district_level",
                    layer = "output")
mpsz <- subset(mpsz, select = c(statename, distname)) 
```

State-wise discrepancies

```{r}
aspatial_states <-  unique(IPC$State)
geospatial_states <- unique(mpsz$statename)
common_states <- intersect(aspatial_states, geospatial_states)


aspatial_minus_geospatial_states <- setdiff(aspatial_states, common_states)
geospatial_minus_aspatial_states <- setdiff(geospatial_states, common_states)
```

```{r}
aspatial_minus_geospatial_states
```

```{r}
geospatial_minus_aspatial_states
```

Here, the aspatial naming will be followed.

```{r}
mpsz <- mpsz %>%
        mutate(statename = recode(statename,
                                  "Chhatisgarh" = "Chhattisgarh",
                                  "Orissa" = "Odisha",
                                  "Andaman & Nicobar Islands" = "A&N Islands",
                                  "Daman & Diu" = "D&N Haveli and Daman & Diu",
                                  "Dadra & Nagar Haveli" = "D&N Haveli and Daman & Diu",
                                  "NCT of Delhi" = "Delhi",
                                  "Pondicherry" = "Puducherry"))
```

District version

```{r}
aspatial_districts <-  unique(IPC$District)
geospatial_districts <- unique(mpsz$distname)
common_districts <- intersect(aspatial_districts, geospatial_districts)


aspatial_minus_geospatial_districts <- setdiff(aspatial_districts, common_districts)
geospatial_minus_aspatial_districts <- setdiff(geospatial_districts, common_districts)
```

```{r}
aspatial_minus_geospatial_districts
```

```{r}
geospatial_minus_aspatial_districts
```

Too many here!

Here, the geospatial naming will be followed.

```{r}
# distance_df <- data.frame(matrix(nrow = 0, ncol = 3))
# colnames(distance_df) = c("aspatial", "similarity", "closest geospatial")
```

```{r}
new_aspatial <- list()
threshold <- 0.149 # more similar means smaller value
#aspatial_districts <- IPC$District
num <- nrow(IPC)

for(i in 1:num) {
  
  row <- IPC[i,]
  state <- row$State
  value <- row$District
  
  distances <- stringdist(value, geospatial_districts, method = "jw") #distance matrix
  closest_match_index <- which.min(distances) #index
  closest_match <- geospatial_districts[closest_match_index]
  closest_match_state <- mpsz[mpsz$distname == closest_match, ]$statename
  
  #similar enough and same state
  if ((distances[closest_match_index] <= threshold) && (state == closest_match_state)) {
    new_aspatial <- c(new_aspatial, closest_match)
    
  } 
  #not similar enough 
  else {
    new_aspatial <- c(new_aspatial, value)
  }
  
  #distance_df[nrow(distance_df) + 1, ] = c(value, distances[closest_match_index], closest_match)
  
}
new_aspatial <- flatten_chr(new_aspatial)
IPC$District <- new_aspatial
```

Numbers after fuzzy search

```{r}
aspatial_districts <-  unique(IPC$District)
geospatial_districts <- unique(mpsz$distname)
common_districts <- intersect(aspatial_districts, geospatial_districts)


aspatial_minus_geospatial_districts <- setdiff(aspatial_districts, common_districts)
geospatial_minus_aspatial_districts <- setdiff(geospatial_districts, common_districts)
```

```{r}
aspatial_minus_geospatial_districts
```

```{r}
geospatial_minus_aspatial_districts
```

Much better but still a lot of work to preprocess

Move to csv for easier lookup

```{r}
#| eval: false
#write.csv(data.frame(aspatial_minus_geospatial_districts), "asp.csv", row.names = FALSE)
#write.csv(mpsz %>% st_drop_geometry(), "geomap.csv", row.names = FALSE)
```

------------------------------------------------------------------------

After checking, here's the new list

\*\* There were lots of mismatched data because the geospatial data is from 2014 and the aspatial data is from 2021. There have been several changes to the names and divisions. Furthermore, the aspaital data is very unclean as it contains sub-districts and towns along with district names. \*\*

```{r}
#IPC <- read_rds("data/aspatial/rds/IPC.rds")
unique_aspatial_districts <- read.csv(file = 'asp.csv')

#replace the names in the IPC file
IPC$District[match(unique_aspatial_districts$oldname, IPC$District)] <- unique_aspatial_districts$newname

#remove irrelevant variables
IPC <- IPC[IPC$District != "remove", ]
```

Check again

Note - Mismatch value should have come down

```{r}
aspatial_districts <-  unique(IPC$District)
geospatial_districts <- unique(mpsz$distname)
common_districts <- intersect(aspatial_districts, geospatial_districts)


aspatial_minus_geospatial_districts <- setdiff(aspatial_districts, common_districts)
geospatial_minus_aspatial_districts <- setdiff(geospatial_districts, common_districts)
```

Other than Warangal and Kashmir that have been changed, Mumbai Sundarbans need to be added into Mumbai and the remaining data is to be removed

```{r}
aspatial_minus_geospatial_districts
```

```{r}
geospatial_minus_aspatial_districts
```

For the aspatial data, CID, GRP, Cyber, Crime Branch and Cyber Cell are not needed.

```{r}
IPC <-IPC[!(IPC$District=="CID" | IPC$District=="GRP" | IPC$District=="Crime Branch" | IPC$District=="Cyber" | IPC$District=="Cyber Cell"),]
```

For the geospatial data, renaming has to be done to accomodate Kashmir, Warangal (R) and (U) and Mumbai and Mumbai Suburban have to be joined. Further changes will be checked after.

```{r}
#change names
mpsz$distname[mpsz$distname == "DATA NOT AVAILABLE"] <- "Kashmir"
mpsz$distname[mpsz$distname == "Warangal (R)"] <- "Warangal"
mpsz$distname[mpsz$distname == "Warangal (U)"] <- "Warangal"
mpsz$distname[mpsz$distname == "Mumbai Suburban"] <- "Mumbai"

#combine geometry
mpsz$geometry[mpsz$distname == "Warangal"] <- st_combine(mpsz$geometry[mpsz$distname == "Warangal"])
mpsz$geometry[mpsz$distname == "Mumbai"] <- st_combine(mpsz$geometry[mpsz$distname == "Mumbai"])

```

```{r}
#check combination 
#plot(test_mpsz[445,])
```

Now there won't be any aspatial values left to process. The geospatial values will require manual lookup and changes will be made to the aspatial dataset.

Most of the geospatial values are either incomplete district names for certain states or retired districts

```{r}
#geospatial_minus_aspatial_districts
```

```{r}
#Sikkim State
IPC$District[IPC$District == "North" & IPC$State == "Sikkim"] <- "North District"
IPC$District[IPC$District == "East" & IPC$State == "Sikkim"] <- "East District"
IPC$District[IPC$District == "South" & IPC$State == "Sikkim"] <- "South District"
IPC$District[IPC$District == "West" & IPC$State == "Sikkim"] <- "West District"

#Tripura State
IPC$District[IPC$District == "West" & IPC$State == "Tripura"] <- "West Tripura"
IPC$District[IPC$District == "North" & IPC$State == "Tripura"] <- "North Tripura"
IPC$District[IPC$District == "South" & IPC$State == "Tripura"] <- "South Tripura"

#Pondicherry State - Mahe and Yanam - suss - merge geometry 
mpsz$distname[mpsz$distname == "Mahe"] <- "Puducherry"
mpsz$distname[mpsz$distname == "Yanam"] <- "Puducherry"


#Odisha State - no data so merge into Puri
mpsz$distname[mpsz$distname == "Khordha"] <- "Puri"
mpsz$geometry[mpsz$distname == "Puri"] <- st_combine(mpsz$geometry[mpsz$distname == "Puri"])


#Telangana State
mpsz$distname[mpsz$distname == "Jangaon"] <- "Warangal"
mpsz$geometry[mpsz$distname == "Warangal"] <- st_combine(mpsz$geometry[mpsz$distname == "Warangal"])
mpsz$distname[mpsz$distname == "Mancherial"] <- "Adilabad"
mpsz$geometry[mpsz$distname == "Adilabad"] <- st_combine(mpsz$geometry[mpsz$distname == "Adilabad"])
mpsz$distname[mpsz$distname == "Rangareddy"] <- "Hydrabad"
mpsz$geometry[mpsz$distname == "Hydrabad"] <- st_combine(mpsz$geometry[mpsz$distname == "Hydrabad"])
mpsz$distname[mpsz$distname == "Peddapalli"] <- "Karimnagar"
mpsz$geometry[mpsz$distname == "Karimnagar"] <- st_combine(mpsz$geometry[mpsz$distname == "Karimnagar"])
mpsz$distname[mpsz$distname == "Yadadri"] <- "Nalgonda"
mpsz$geometry[mpsz$distname == "Nalgonda"] <- st_combine(mpsz$geometry[mpsz$distname == "Nalgonda"])
mpsz <- mpsz[mpsz$distname != "Medchal", ] #remove
```

Clean the data

For geospatial data, remove duplicates

```{r}
#remove duplicate rows
mpsz <- mpsz[-c(677, 662, 448, 669, 672, 679, 687),]

#reset index
rownames(mpsz) <- NULL
```

For aspatial data, group same values

```{r}
IPC <- IPC %>% group_by(State,District) %>% 
  summarise(across(c(colnames(IPC)[3:14]),sum),
            .groups = 'drop') %>%
  as.data.frame()
```

Save checkpoints as rds

```{r}
write_rds(IPC, "data/aspatial/rds/IPC_clean.rds")
write_rds(mpsz, "data/geospatial/rds/map_clean.rds")
```

------------------------------------------------------------------------

Now for the SLL dataset,

```{r}
SLL <- read_rds("data/aspatial/rds/SLL.rds")
mpsz <- read_rds("data/geospatial/rds/map_clean.rds")
```

State names have already been cleaned so district names are to be done

```{r}
aspatial_districts <-  unique(SLL$District)
geospatial_districts <- unique(mpsz$distname)
common_districts <- intersect(aspatial_districts, geospatial_districts)


aspatial_minus_geospatial_districts <- setdiff(aspatial_districts, common_districts)
geospatial_minus_aspatial_districts <- setdiff(geospatial_districts, common_districts)
```

```{r}
aspatial_minus_geospatial_districts
```

```{r}
geospatial_minus_aspatial_districts
```

Too many mismatched values as expected. Perform fuzzy search as earlier.

```{r}
new_aspatial <- list()
threshold <- 0.149 # more similar means smaller value
#aspatial_districts <- SLL$District
num <- nrow(SLL)

for(i in 1:num) {
  
  row <- SLL[i,]
  state <- row$State
  value <- row$District
  
  distances <- stringdist(value, geospatial_districts, method = "jw") #distance matrix
  closest_match_index <- which.min(distances) #index
  closest_match <- geospatial_districts[closest_match_index]
  closest_match_state <- mpsz[mpsz$distname == closest_match, ]$statename
  
  #similar enough and same state
  if ((distances[closest_match_index] <= threshold) && (state == closest_match_state)) {
    new_aspatial <- c(new_aspatial, closest_match)
    
  } 
  #not similar enough 
  else {
    new_aspatial <- c(new_aspatial, value)
  }
  
  #distance_df[nrow(distance_df) + 1, ] = c(value, distances[closest_match_index], closest_match)
  
}
new_aspatial <- flatten_chr(new_aspatial)
SLL$District <- new_aspatial
```

Check mistmatch

```{r}
aspatial_districts <-  unique(SLL$District)
geospatial_districts <- unique(mpsz$distname)
common_districts <- intersect(aspatial_districts, geospatial_districts)


aspatial_minus_geospatial_districts <- setdiff(aspatial_districts, common_districts)
geospatial_minus_aspatial_districts <- setdiff(geospatial_districts, common_districts)
```

```{r}
aspatial_minus_geospatial_districts
```

```{r}
geospatial_minus_aspatial_districts
```

Mismatched rows have come down from 415 to 307 for the aspatial values and from 209 to 119 for the geospatial values.

There is still a lot of preprocessing left that needs to be done manually.

```{r}
#| eval: false
#write.csv(data.frame(aspatial_minus_geospatial_districts), "sll_asp.csv", row.names = FALSE)
#write.csv(mpsz %>% st_drop_geometry(), "geomap.csv", row.names = FALSE)
```

As the IPC and SLL datasets follow the same format, the values after preprocessing can be reused.

```{r}
#SLL <- read_rds("data/aspatial/rds/SLL.rds")
unique_aspatial_districts <- read.csv(file = 'sll_asp.csv')

#replace the names in the IPC file
SLL$District[match(unique_aspatial_districts$oldname, SLL$District)] <- unique_aspatial_districts$newname

#remove irrelevant variables
SLL <- SLL[SLL$District != "remove", ]
```

Check again

Note - Mismatch value should have come down

```{r}
aspatial_districts <-  unique(SLL$District)
geospatial_districts <- unique(mpsz$distname)
common_districts <- intersect(aspatial_districts, geospatial_districts)


aspatial_minus_geospatial_districts <- setdiff(aspatial_districts, common_districts)
geospatial_minus_aspatial_districts <- setdiff(geospatial_districts, common_districts)
```

```{r}
aspatial_minus_geospatial_districts
```

```{r}
geospatial_minus_aspatial_districts
```

For the aspatial data, CID, GRP, Cyber, Crime Branch and Cyber Cell are not needed.

```{r}
SLL <-SLL[!(SLL$District=="CID" | SLL$District=="GRP" | SLL$District=="Crime Branch" | SLL$District=="Cyber" | SLL$District=="Cyber Cell"),]
```

```{r}
#Sikkim State
SLL$District[SLL$District == "North" & SLL$State == "Sikkim"] <- "North District"
SLL$District[SLL$District == "East" & SLL$State == "Sikkim"] <- "East District"
SLL$District[SLL$District == "South" & SLL$State == "Sikkim"] <- "South District"
SLL$District[SLL$District == "West" & SLL$State == "Sikkim"] <- "West District"

#Tripura State
SLL$District[SLL$District == "West" & SLL$State == "Tripura"] <- "West Tripura"
SLL$District[SLL$District == "North" & SLL$State == "Tripura"] <- "North Tripura"
SLL$District[SLL$District == "South" & SLL$State == "Tripura"] <- "South Tripura"

```

After this district Anantapur from Andhra Pradesh will be left because there are no values for it. This can be left as it or the data can be removed from IPC for the sake of uniformity. Leaving it as it for now.

For aspatial data, group same values

```{r}
SLL <- SLL %>% group_by(State,District) %>% 
  summarise(across(c(colnames(SLL)[3:16]),sum),
            .groups = 'drop') %>%
  as.data.frame()
```

Save checkpoints as rds

```{r}
write_rds(SLL, "data/aspatial/rds/SLL_clean.rds")
```
